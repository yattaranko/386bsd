UFS(5)                        File Formats Manual                       UFS(5)

[1mNAME[0m
       ufs, ufs_inode ‚Äî format of UFS file system volume

[1mSYNOPSIS[0m
       [1m$(NONSTDINC) += $(INCFS)[0m
       [1m#include <sys/types.h>[0m
       [1m#include "ufs.h"[0m
       [1m#include "ufs_inode.h"[0m

[1mDESCRIPTION[0m
       The files ‚ü®[4mufs.h[24m‚ü© and ‚ü®[4mufs_inode.h[24m‚ü© declare several structures, defined
       variables and macros which are used to create and manage the underlying
       format of file system objects on random access devices (disks).

       The  block  size  and number of blocks which comprise a file system are
       parameters of the file system.  Sectors beginning at BBLOCK and contin‚Äê
       uing for BBSIZE are used for a disklabel and for some hardware  primary
       and secondary bootstrapping programs.

       The  actual  file  system  begins at sector SBLOCK with the [4msuper‚Äêblock[0m
       that is of size SBSIZE.  The following structure described  the  super‚Äê
       block and is from the file ‚ü®[4mufs.h[24m‚ü©:

       #define FS_MAGIC 0x011954
       struct fs {
               struct  fs *fs_link;    /* linked list of file systems */
               struct  fs *fs_rlink;   /*     used for incore super blocks */
               daddr_t fs_sblkno;      /* addr of super‚Äêblock in filesys */
               daddr_t fs_cblkno;      /* offset of cyl‚Äêblock in filesys */
               daddr_t fs_iblkno;      /* offset of inode‚Äêblocks in filesys */
               daddr_t fs_dblkno;      /* offset of first data after cg */
               long    fs_cgoffset;    /* cylinder group offset in cylinder */
               long    fs_cgmask;      /* used to calc mod fs_ntrak */
               time_t  fs_time;        /* last time written */
               long    fs_size;        /* number of blocks in fs */
               long    fs_dsize;       /* number of data blocks in fs */
               long    fs_ncg; /* number of cylinder groups */
               long    fs_bsize;       /* size of basic blocks in fs */
               long    fs_fsize;       /* size of frag blocks in fs */
               long    fs_frag;        /* number of frags in a block in fs */
       /* these are configuration parameters */
               long    fs_minfree;     /* minimum percentage of free blocks */
               long    fs_rotdelay;    /* num of ms for optimal next block */
               long    fs_rps; /* disk revolutions per second */
       /* these fields can be computed from the others */
               long    fs_bmask;       /* ‚Äò‚Äòblkoff‚Äô‚Äô calc of blk offsets */
               long    fs_fmask;       /* ‚Äò‚Äòfragoff‚Äô‚Äô calc of frag offsets */
               long    fs_bshift;      /* ‚Äò‚Äòlblkno‚Äô‚Äô calc of logical blkno */
               long    fs_fshift;      /* ‚Äò‚Äònumfrags‚Äô‚Äô calc number of frags */
       /* these are configuration parameters */
               long    fs_maxcontig;   /* max number of contiguous blks */
               long    fs_maxbpg;      /* max number of blks per cyl group */
       /* these fields can be computed from the others */
               long    fs_fragshift;   /* block to frag shift */
               long    fs_fsbtodb;     /* fsbtodb and dbtofsb shift constant */
               long    fs_sbsize;      /* actual size of super block */
               long    fs_csmask;      /* csum block offset */
               long    fs_csshift;     /* csum block number */
               long    fs_nindir;      /* value of NINDIR */
               long    fs_inopb;       /* value of INOPB */
               long    fs_nspf;        /* value of NSPF */
       /* yet another configuration parameter */
               long    fs_optim;       /* optimization preference, see below */
       /* these fields are derived from the hardware */
               long    fs_npsect;      /* # sectors/track including spares */
               long    fs_interleave;  /* hardware sector interleave */
               long    fs_trackskew;   /* sector 0 skew, per track */
               long    fs_headswitch;  /* head switch time, usec */
               long    fs_trkseek;     /* track‚Äêto‚Äêtrack seek, usec */
       /* sizes determined by number of cylinder groups and their sizes */
               daddr_t fs_csaddr;      /* blk addr of cyl grp summary area */
               long    fs_cssize;      /* size of cyl grp summary area */
               long    fs_cgsize;      /* cylinder group size */
       /* these fields are derived from the hardware */
               long    fs_ntrak;       /* tracks per cylinder */
               long    fs_nsect;       /* sectors per track */
               long    fs_spc;         /* sectors per cylinder */
       /* this comes from the disk driver partitioning */
               long    fs_ncyl;        /* cylinders in file system */
       /* these fields can be computed from the others */
               long    fs_cpg; /* cylinders per group */
               long    fs_ipg; /* inodes per group */
               long    fs_fpg; /* blocks per group * fs_frag */
       /* this data must be re‚Äêcomputed after crashes */
               struct  csum fs_cstotal;        /* cylinder summary information */
       /* these fields are cleared at mount time */
               char    fs_fmod;        /* super block modified flag */
               char    fs_clean;       /* file system is clean flag */
               char    fs_ronly;       /* mounted read‚Äêonly flag */
               char    fs_flags;       /* currently unused flag */
               char    fs_fsmnt[MAXMNTLEN];    /* name mounted on */
       /* these fields retain the current block allocation info */
               long    fs_cgrotor;     /* last cg searched */
               struct  csum *fs_csp[MAXCSBUFS]; /* list of fs_cs info buffers */
               long    fs_cpc; /* cyl per cycle in postbl */
               short   fs_opostbl[16][8];      /* old rotation block list head */
               long    fs_sparecon[56];        /* reserved for future constants */
               quad    fs_qbmask;      /* Àúfs_bmask ‚Äê for use with quad size */
               quad    fs_qfmask;      /* Àúfs_fmask ‚Äê for use with quad size */
               long    fs_postblformat; /* format of positional layout tables */
               long    fs_nrpos;       /* number of rotaional positions */
               long    fs_postbloff;   /* (short) rotation block list head */
               long    fs_rotbloff;    /* (u_char) blocks for each rotation */
               long    fs_magic;       /* magic number */
               u_char  fs_space[1];    /* list of blocks for each rotation */
       /* actually longer */
       };

       Each  disk  drive  contains some number of file systems.  A file system
       consists of a number of cylinder groups.  Each cylinder group  has  in‚Äê
       odes and data.

       A  file system is described by its super‚Äêblock, which in turn describes
       the cylinder groups.  The super‚Äêblock is critical data  and  is  repli‚Äê
       cated  in  each  cylinder  group  to protect against catastrophic loss.
       This is done at file system creation time and the critical  super‚Äêblock
       data  does not change, so the copies need not be referenced further un‚Äê
       less disaster strikes.

       Addresses stored in inodes  are  capable  of  addressing  fragments  of
       ‚Äòblocks‚Äô. File system blocks of at most size MAXBSIZE can be optionally
       broken  into  2,  4,  or  8 pieces, each of which is addressable; these
       pieces may be DEV_BSIZE, or some multiple of a DEV_BSIZE unit.

       Large files consist of exclusively large data blocks.  To  avoid  undue
       wasted  disk space, the last data block of a small file is allocated as
       only as many fragments of a large block as  are  necessary.   The  file
       system  format  retains only a single pointer to such a fragment, which
       is a piece of a single large block that has been divided.  The size  of
       such  a  fragment  is determinable from information in the inode, using
       the [1mblksize[22m([4mfs[24m, [4mip[24m, [4mlbn[24m) macro.

       The file system records space availability at the  fragment  level;  to
       determine block availability, aligned fragments are examined.

       The  root  inode is the root of the file system.  Inode 0 can‚Äôt be used
       for normal purposes and historically bad blocks were linked to inode 1,
       thus the root inode is 2 (inode 1 is no longer used for  this  purpose,
       however  numerous dump tapes make this assumption, so we are stuck with
       it).

       The [4mfs_minfree[24m element gives the minimum acceptable percentage of  file
       system  blocks that may be free. If the freelist drops below this level
       only the super‚Äêuser may continue to allocate  blocks.   The  [4mfs_minfree[0m
       element  may  be set to 0 if no reserve of free blocks is deemed neces‚Äê
       sary, however severe performance degradations will be observed  if  the
       file  system is run at greater than 90% full; thus the default value of
       [4mfs_minfree[24m is 10%.

       Empirically the best trade‚Äêoff between block fragmentation and  overall
       disk  utilization  at a loading of 90% comes with a fragmentation of 8,
       thus the default fragment size is an eighth of the block size.

       The element [4mfs_optim[24m specifies whether the file system  should  try  to
       minimize  the  time spent allocating blocks, or if it should attempt to
       minimize the space fragmentation on the disk.  If the value of  fs_min‚Äê
       free (see above) is less than 10%, then the file system defaults to op‚Äê
       timizing  for  space to avoid running out of full sized blocks.  If the
       value of minfree is greater than or equal to 10%, fragmentation is  un‚Äê
       likely  to be problematical, and the file system defaults to optimizing
       for time.

       [4mCylinder[24m [4mgroup[24m [4mrelated[24m [4mlimits[24m: Each cylinder keeps track of the  avail‚Äê
       ability of blocks at different rotational positions, so that sequential
       blocks  can  be  laid out with minimum rotational latency. With the de‚Äê
       fault of 8 distinguished rotational positions, the  resolution  of  the
       summary information is 2ms for a typical 3600 rpm drive.

       The  element  [4mfs_rotdelay[24m  gives  the minimum number of milliseconds to
       initiate another disk transfer on the same cylinder.  It is used in de‚Äê
       termining the rotationally optimal layout  for  disk  blocks  within  a
       file; the default value for [4mfs_rotdelay[24m is 2ms.

       Each file system has a statically allocated number of inodes.  An inode
       is  allocated  for each NBPI bytes of disk space.  The inode allocation
       strategy is extremely conservative.

       MINBSIZE is the smallest allowable block size.  With a MINBSIZE of 4096
       it is possible to create files of size 2ÀÜ32 with only two levels of in‚Äê
       direction.  MINBSIZE must be big enough to hold a cylinder group block,
       thus changes to ([4mstruct[24m [4mcg[24m) must keep its size within  MINBSIZE.   Note
       that super‚Äêblocks are never more than size SBSIZE.

       The  path  name  on  which  the file system is mounted is maintained in
       [4mfs_fsmnt[24m.  MAXMNTLEN defines the amount of space allocated in  the  su‚Äê
       per‚Äêblock  for  this name.  The limit on the amount of summary informa‚Äê
       tion per file system is defined by MAXCSBUFS. For  a  4096  byte  block
       size, it is currently parameterized for a maximum of two million cylin‚Äê
       ders.

       Per  cylinder  group information is summarized in blocks allocated from
       the first cylinder group‚Äôs data blocks.  These blocks are read in  from
       [4mfs_csaddr[24m (size [4mfs_cssize[24m) in addition to the super‚Äêblock.

       [1mN.B.:  [4m[22msizeof[24m  ([4mstruct[24m  [4mcsum[24m)  must  be a power of two in order for the
       [1mfs_cs[22m() macro to work.

       The [4mSuper‚Äêblock[24m [4mfor[24m [4ma[24m [4mfile[24m [4msystem[24m: The size of  the  rotational  layout
       tables  is  limited by the fact that the super‚Äêblock is of size SBSIZE.
       The size of these tables is [4minversely[24m proportional to the block size of
       the file system. The size of the tables is increased when sector  sizes
       are  not  powers  of two, as this increases the number of cylinders in‚Äê
       cluded before the rotational pattern repeats ([4mfs_cpc[24m).  The size of the
       rotational layout tables is derived from the number of bytes  remaining
       in ([4mstruct[24m [4mfs[24m).

       The  number  of  blocks  of  data per cylinder group is limited because
       cylinder groups are at most one block.  The inode and free block tables
       must fit into a single block after deducting  space  for  the  cylinder
       group structure ([4mstruct[24m [4mcg[24m).

       The [4mInode[24m: The inode is the focus of all file activity in the UNIX file
       system.   There  is a unique inode allocated for each active file, each
       current directory, each mounted‚Äêon file, text file, and the  root.   An
       inode is ‚Äònamed‚Äô by its device/i‚Äênumber pair.  For further information,
       see the include file ‚ü®[4mufs_inode.h[24m‚ü©.

[1mHISTORY[0m
       A  super‚Äêblock  structure named filsys appeared in Version 6 AT&T UNIX.
       The file system described in this manual appeared in 4.2BSD.

4.2 Berkeley Distribution       April 28, 1994                          UFS(5)
