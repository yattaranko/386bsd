ROUTE(4)                    Kernel Interfaces Manual                  ROUTE(4)

[1mNAME[0m
       route ‚Äî Kernel Packet Forwarding Database

[1mMODULE[0m
       [1mroute <protocol‚Äêfamily>.[0m

[1mSYNOPSIS[0m
       [1mMakefile:[0m
       [1m$(NONSTDINC) += $(INCNET)[0m

       [1mC:[0m
       [1m#include <sys/socket.h>[0m
       [1m#include "if.h"[0m
       [1m#include "route.h"[0m

       [4mint[0m
       [1msocket[22m([4mPF_ROUTE[24m, [4mSOCK_RAW[24m, [4mint[24m [4mfamily[24m);

[1mDESCRIPTION[0m
       386BSD provides some packet routing facilities.  The kernel maintains a
       routing  information database, which is used in selecting the appropri‚Äê
       ate network interface when transmitting packets. These  facilities  are
       implemented in a module that provides routing independant of protocol.

       A  user process (or possibly multiple co‚Äêoperating processes) maintains
       this database by sending messages over a special kind of socket.   This
       supplants  fixed size [4mioctl[24m(2)‚Äôs used in earlier releases.  Routing ta‚Äê
       ble changes may only be carried out by the super user.

       The operating system may spontaneously emit  routing  messages  in  re‚Äê
       sponse to external events, such as recipt of a re‚Äêdirect, or failure to
       locate a suitable route for a request.  The message types are described
       in greater detail below.

       Routing  database  entries come in two flavors: for a specific host, or
       for all hosts on a generic subnetwork (as specified by a bit  mask  and
       value  under  the mask.  The effect of wildcard or default route may be
       achieved by using a mask of all zeros, and there  may  be  hierarchical
       routes.

       When the system is booted and addresses are assigned to the network in‚Äê
       terfaces,  each protocol family installs a routing table entry for each
       interface when it is ready for traffic.  Normally the  protocol  speci‚Äê
       fies  the  route through each interface as a ‚Äúdirect‚Äù connection to the
       destination host or network.  If the route  is  direct,  the  transport
       layer  of  a protocol family usually requests the packet be sent to the
       same host specified in the packet.  Otherwise,  the  interface  is  re‚Äê
       quested  to address the packet to the gateway listed in the routing en‚Äê
       try (i.e. the packet is forwarded).

       When routing a packet, the kernel will first attempt to find a route to
       the destination host.  Failing that, a search is made for  a  route  to
       the  network  of  the  destination.   Finally,  any  route to a default
       (‚Äúwildcard‚Äù) gateway is chosen.  If no entry is found, the  destination
       is  declared to be unreachable, and a routing-miss message is generated
       if there are any listers on the routing control socket described below.

       A wildcard routing entry is specified with a zero  destination  address
       value.   Wildcard  routes are used only when the system fails to find a
       route to the destination host and network.  The combination of wildcard
       routes and routing redirects can provide an  economical  mechanism  for
       routing traffic.

       One  opens  the  channel for passing routing control messasges by using
       the socket call shown in the synopsis above:

       The [4mfamily[24m paramter may be AF_UNSPEC which will provide routing  infor‚Äê
       mation for all address families, or can be restricted to a specific ad‚Äê
       dress  family  by  specifying  which one is desired.  There can be more
       than one routing socket open per system.

       Messages are formed by a header followed by a small number  of  sockad‚Äê
       ders (now variable length particularly in the ISO case), interpreted by
       position,  and  delimited  by the new length entry in the sockaddr.  An
       example of a message with four addresses might be an ISO redirect: Des‚Äê
       tination, Netmask, Gateway, and Author of the redirect.  The  interpre‚Äê
       tation  of  which address are present is given by a bit mask within the
       header, and the sequence is least significant to most  significant  bit
       within the vector.

       Any  messages  sent  to the kernel are returned, and copies are sent to
       all interested listeners.  The kernel will provide the process id.  for
       the sender, and the sender may use an additional sequence field to dis‚Äê
       tinguish between outstanding messages.  However, message replies may be
       lost when kernel buffers are exhausted.

       The kernel may reject certain messages, and will indicate this by fill‚Äê
       ing  in  the  [4mrtm_errno[24m  field.  The routing code returns EEXIST if re‚Äê
       quested to duplicate an existing entry, ESRCH if requested to delete  a
       non‚Äêexistent entry, or ENOBUFS if insufficient resources were available
       to  install  a  new  route.  In the current implementation, all routing
       process run locally, and the values for [4mrtm_errno[24m are available through
       the normal [4merrno[24m mechanism, even if the routing reply message is lost.

       A process may avoid the expense of reading replies to its own  messages
       by  issuing a [4msetsockopt[24m(2) call indicating that the SO_USELOOPBACK op‚Äê
       tion at the SOL_SOCKET level is to be turned off.  A process may ignore
       all messages from the routing socket by doing a [4mshutdown[24m(2) system call
       for further input.

       If a route is in use when it is deleted,  the  routing  entry  will  be
       marked down and removed from the routing table, but the resources asso‚Äê
       ciated with it will not be reclaimed until all references to it are re‚Äê
       leased.   User processes can obtain information about the routing entry
       to a specific destination by using a RTM_GET message, or by reading the
       [4m/dev/kmem[24m device, or by issuing a [4mgetkerninfo[24m(2) system call.

       Messages include:

       #define RTM_ADD         0x1    /* Add Route */
       #define RTM_DELETE      0x2    /* Delete Route */
       #define RTM_CHANGE      0x3    /* Change Metrics, Flags, or Gateway */
       #define RTM_GET         0x4    /* Report Information */
       #define RTM_LOOSING     0x5    /* Kernel Suspects Partitioning */
       #define RTM_REDIRECT    0x6    /* Told to use different route */
       #define RTM_MISS        0x7    /* Lookup failed on this address */
       #define RTM_RESOLVE     0xb    /* request to resolve dst to LL addr */

       A message header consists of:

       struct rt_msghdr {
           u_short rmt_msglen;  /* to skip over non‚Äêunderstood messages */
           u_char  rtm_version; /* future binary compatability */
           u_char  rtm_type;    /* message type */
           u_short rmt_index;   /* index for associated ifp */
           pid_t   rmt_pid;     /* identify sender */
           int     rtm_addrs;   /* bitmask identifying sockaddrs in msg */
           int     rtm_seq;     /* for sender to identify action */
           int     rtm_errno;   /* why failed */
           int     rtm_flags;   /* flags, incl kern & message, e.g. DONE */
           int     rtm_use;     /* from rtentry */
           u_long  rtm_inits;   /* which values we are initializing */
           struct  rt_metrics rtm_rmx; /* metrics themselves */
       };

       where

       struct rt_metrics {
           u_long rmx_locks;     /* Kernel must leave these values alone */
           u_long rmx_mtu;       /* MTU for this path */
           u_long rmx_hopcount;  /* max hops expected */
           u_long rmx_expire;    /* lifetime for route, e.g. redirect */
           u_long rmx_recvpipe;  /* inbound delay‚Äêbandwith product */
           u_long rmx_sendpipe;  /* outbound delay‚Äêbandwith product */
           u_long rmx_ssthresh;  /* outbound gateway buffer limit */
           u_long rmx_rtt;       /* estimated round trip time */
           u_long rmx_rttvar;    /* estimated rtt variance */
       };

       Flags include the values:

       #define RTF_UP        0x1    /* route useable */
       #define RTF_GATEWAY   0x2    /* destination is a gateway */
       #define RTF_HOST      0x4    /* host entry (net otherwise) */
       #define RTF_NORMAL    0x8    /* subnet mask is cannonical */
       #define RTF_DYNAMIC   0x10   /* created dynamically (by redirect) */
       #define RTF_MODIFIED  0x20   /* modified dynamically (by redirect) */
       #define RTF_DONE      0x40   /* message confirmed */
       #define RTF_MASK      0x80   /* subnet mask present */

       Specfiers for metric values in rmx_locks and rtm_inits are:

       #define RTV_SSTHRESH  0x1    /* init or lock _ssthresh */
       #define RTV_RPIPE     0x2    /* init or lock _recvpipe */
       #define RTV_SPIPE     0x4    /* init or lock _sendpipe */
       #define RTV_HOPCOUNT  0x8    /* init or lock _hopcount */
       #define RTV_RTT       0x10   /* init or lock _rtt */
       #define RTV_RTTVAR    0x20   /* init or lock _rttvar */
       #define RTV_MTU       0x40   /* init or lock _mtu */

       Specifiers for which addresses are present in the messages are:

       #define RTA_DST       0x1    /* destination sockaddr present */
       #define RTA_GATEWAY   0x2    /* gateway sockaddr present */
       #define RTA_NETMASK   0x4    /* netmask sockaddr present */
       #define RTA_GENMASK   0x8    /* cloning mask sockaddr present */
       #define RTA_IFP       0x10   /* interface name sockaddr present */
       #define RTA_IFA       0x20   /* interface addr sockaddr present */
       #define RTA_AUTHOR    0x40   /* sockaddr for author of redirect */

[1mHISTORY[0m
       The [1mroute [22mforwarding database currently under development.

FreeBSD 13.2                     June 20, 1994                        ROUTE(4)
